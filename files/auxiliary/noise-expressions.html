<!DOCTYPE html><html><head><meta charset="utf-8"><title>Noise Expressions - Auxiliary Docs | Factorio</title><link href="https://cdn.factorio.com/assets/fonts/titillium-web.css" rel="stylesheet"><link href="https://cdn.factorio.com/assets/fonts/roboto-mono.css" rel="stylesheet"><link href="../style.css?v=72ae9920" rel="stylesheet" type="text/css"><meta name="viewport" content="width=device-width"><link rel="shortcut icon" href="../static/favicon.png"><script src="../script.js?v=72ae9920"></script></head><body class="docs docs-wide"><div id="top" class="top-bar mb32"><div class="top-bar-inner"><div class="sites links flex flex-items-baseline" style="width: 100%"><span><a href="https://factorio.com" style="color: #7dcaed;">Factorio.com</a><span class="separator">|</span><a href="https://forums.factorio.com/" style="color: #7dcaed;">Forums</a><span class="separator">|</span><a href="https://wiki.factorio.com/" style="color: #7dcaed;">Wiki</a><span class="separator">|</span><a href="https://mods.factorio.com" style="color: #7dcaed;">Mod Portal</a><span class="separator">|</span><a href="../index.html" class="sites-current">API Docs</a></span><span style="margin-left: auto;"><a href="../index-prototype.html">Prototype</a><span class="separator">|</span><a href="../index-runtime.html">Runtime</a><span class="separator">|</span><a href="../index-auxiliary.html" class="sites-current">Auxiliary</a></span></div></div></div><div class="container"><div class="container-inner"><div id="auxiliary-page"></div> <h1 class="ml8 mr8" style="position: relative;"><a href="../index-auxiliary.html" style="color: #ffe6c0;">Factorio Auxiliary Docs</a><a href="/" class="version-link" style="color: #ffe6c0;"><span class="version-string">Version</span> 2.0.55 <img src="../static/collapse-symbol.png" class="collapse-icon"></a></h1><div id="docs-layout-panel" class="panel flex-column pb0 overflow-unset"><div class="flex flex-reverse docs-panes " style="margin-top: -12px;"><div class="docs-content flex flex-column"><div class="panel-inset breadcrumbs mb0 p4"><span class="breadcrumbs-text"><a href="../index-auxiliary.html">Home</a> / <a href="noise-expressions.html">Noise Expressions</a></span><a id="page-width-button" class="button square-sm" style="float: right;">&gt;&lt;</a></div><div class="panel-inset-lighter" style="flex-grow: 1;"><h2 id="table-of-contents">Table of contents<a class="ml8 link" href="#table-of-contents"><img src="../static/link-symbol.png"></a></h2><ul><li><a href="#identifiers">Identifiers</a></li><li><a href="#built-in-variables">Built-in variables</a></li><li><a href="#built-in-constants">Built-in constants</a></li><li><a href="#built-in-functions">Built-in functions</a></li><li><a href="#performance-tips">Performance tips</a></li></ul><h2 id="noise-expressions">Noise expressions<a class="ml8 link" href="#noise-expressions"><img src="../static/link-symbol.png"></a></h2><p>Noise expressions represent a series of mathematical expressions which are executed for every tile.<br> See the <a href="../types/NoiseExpression.html">NoiseExpression Type</a> for their syntax and this page for the behaviour of identifiers and built-in functions and variables.</p><p>Mods can define their own noise expressions and functions as prototypes and tell the game to use them for map generation.<br> The major entry points for this are <a href="../types/AutoplaceSpecification.html#probability_expression">AutoplaceSpecification::probability_expression</a>, <a href="../types/AutoplaceSpecification.html#richness_expression">AutoplaceSpecification::richness_expression</a> and <a href="../prototypes/NamedNoiseExpression.html">NamedNoiseExpression</a>.</p><hr><h3 id="identifiers">Identifiers<a class="ml8 link" href="#identifiers"><img src="../static/link-symbol.png"></a></h3><p>Identifiers are used to name functions and variables which have their own (return) types:<br> - <strong>Number:</strong> Usually a single-precision floating-point number<br> - <strong>String</strong><br> - <strong>MapPosition</strong><br> - <strong>MapPositionList:</strong> An array of MapPosition variables<br> - <strong>Boolean:</strong> Stored as a number; true for positive numbers, false for negative numbers and zero<br> - <strong>NoiseLayerID:</strong> Stored as a number or a string; string is converted to ID using CRC32</p><h4 id="name-resolution">Name resolution<a class="ml8 link" href="#name-resolution"><img src="../static/link-symbol.png"></a></h4><p>The game engine does not restrict naming of noise functions and noise expressions, although some names may be unusable because of<br> the parser. Function parameters are also parsed as identifiers. Therefore, it is recommended to follow <a href="../types/NoiseExpression.html">identifier</a> format.</p><p>If an expression cannot be parsed as an identifier, it can be accessed via a proxy function <code>var()</code>. For example, if <code>my-noise-expression</code><br> would be entered into the parser directly, it would be treated as a subtraction of three variables - <code>my</code>, <code>noise</code> and <code>expression</code><br> instead of one variable name. To use such variable, we can call <code>var('my-noise-expression')</code>. Function names and function parameters<br> do not have alternative ways of accessing them.</p><h4 id="name-collisions">Name collisions<a class="ml8 link" href="#name-collisions"><img src="../static/link-symbol.png"></a></h4><p>The parser has some rules to resolve name collisions, applied in order until an expression/function is found:<br> 1. Try to find the most local noise expression/function, taking into account function parameters.<br> 2. Check <code>property_expression_names</code> defined in <a href="../concepts/MapGenSettings.html">MapGenSettings</a>.<br> 3. Check global prototype names (<a href="../prototypes/NamedNoiseExpression.html">named noise expressions</a>/<a href="../prototypes/NamedNoiseFunction.html">functions</a>).<br> 4. Check built-in constants, variables and functions.</p><hr><h3 id="built-in-variables">Built-in variables<a class="ml8 link" href="#built-in-variables"><img src="../static/link-symbol.png"></a></h3><ul><li><strong>x</strong> (Number): Current X position on the map.</li><li><strong>y</strong> (Number): Current Y position on the map.</li></ul><p>Noise expressions of all tiles, entities and decoratives which will be generated on map can also be accessed as variables.<br> By default, noise expressions from prototype autoplace specification are used, but they can be overwritten with <a href="../concepts/MapGenSettings.html#property_expression_names">MapGenSettings::property_expression_names</a>.<br> - <strong>decorative:my-decorative-name:probability</strong> (Number)<br> - <strong>decorative:my-decorative-name:richness</strong> (Number)<br> - <strong>entity:my-entity-name:probability</strong> (Number)<br> - <strong>entity:my-entity-name:richness</strong> (Number)<br> - <strong>tile:my-tile-name:probability</strong> (Number)<br> - <strong>tile:my-tile-name:richness</strong> (Number)</p><h3 id="built-in-constants">Built-in constants<a class="ml8 link" href="#built-in-constants"><img src="../static/link-symbol.png"></a></h3><p>Constants defined by the parser:<br> - <strong>true</strong> (Number): 1<br> - <strong>false</strong> (Number): 0<br> - <strong>e</strong> (Number): Euler's number<br> - <strong>pi</strong> (Number): ~3.14159<br> - <strong>inf</strong> (Number): infinity</p><p>Constants from <a href="../concepts/MapGenSettings.html">MapGenSettings</a>:<br> - <strong>map_seed</strong> (Number): 32-bit unsigned integer<br> - <strong>map_seed_small</strong> (Number): 16 least significant bits from <code>map_seed</code><br> - <strong>map_seed_normalized</strong> (Number): 0-1 normalized value of <code>map_seed</code><br> - <strong>map_width</strong> (Number)<br> - <strong>map_height</strong> (Number)<br> - <strong>starting_area_radius</strong> (Number)<br> - <strong>cliff_elevation_0</strong> (Number)<br> - <strong>cliff_elevation_interval</strong> (Number)<br> - <strong>cliff_smoothing</strong> (Number)<br> - <strong>cliff_richness</strong> (Number)<br> - <strong>starting_positions</strong> (MapPositionList)<br> - <strong>starting_lake_positions</strong> (MapPositionList): calculated from starting positions and map seed<br> - <strong>peaceful_mode</strong> (Boolean)<br> - <strong>no_enemies_mode</strong> (Boolean)<br> - <strong>control:moisture:frequency</strong> (Number)<br> - <strong>control:moisture:bias</strong> (Number)<br> - <strong>control:aux:frequency</strong> (Number)<br> - <strong>control:aux:bias</strong> (Number)</p><p>In addition to the hard-coded values, all <a href="../prototypes/AutoplaceControl.html">autoplace controls</a> are converted to frequency, size and richness constants. Because their name contains '-' character, they have to be accessed via <code>var()</code> function.<br> - <strong>control:my-autoplace-name:frequency</strong> (Number)<br> - <strong>control:my-autoplace-name:size</strong> (Number)<br> - <strong>control:my-autoplace-name:richness</strong> (Number)</p><h3 id="built-in-functions">Built-in functions<a class="ml8 link" href="#built-in-functions"><img src="../static/link-symbol.png"></a></h3><h4 id="abs">abs<a class="ml8 link" href="#abs"><img src="../static/link-symbol.png"></a></h4><p>Returns absolute value of the given argument; i.e. if the argument is negative, it is inverted.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="atan2">atan2<a class="ml8 link" href="#atan2"><img src="../static/link-symbol.png"></a></h4><p>Returns the arc tangent of y/x using the signs of arguments to determine the correct quadrant.</p><p><strong>Parameters:</strong><br> - <strong>y</strong> (Number)<br> - <strong>x</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="basis_noise">basis_noise<a class="ml8 link" href="#basis_noise"><img src="../static/link-symbol.png"></a></h4><p>A Factorio single-octave noise implementation.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>seed0</strong> (Number; constant; converted to 32-bit unsigned integer)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>input_scale</strong> (Number; constant; default = 1): x and y will be multiplied by this before sampling<br> - <strong>output_scale</strong> (Number; constant; default = 1): output will be multiplied by this before being returned<br> - <strong>offset_x</strong> (Number; constant; default = 0): will be added to x before applying input_scale<br> - <strong>offset_y</strong> (Number; constant; default = 0): will be added to y before applying input_scale</p><p><strong>Return type:</strong> Number</p><p>Using <code>input_scale</code> and <code>output_scale</code> is more efficient than multiplying <code>x</code> and <code>y</code> directly; see the<br><a href="#noise-seed-input-scale-and-output-scale">performance tips</a>.</p><p><strong>Examples:</strong><br><code>basis_noise{x = x, y = y, seed0 = map_seed, seed1 = 0} basis_noise{x = x, y = y, seed0 = map_seed, seed1 = 0, input_scale = 1/3, output_scale = 3}</code></p><h4 id="ceil">ceil<a class="ml8 link" href="#ceil"><img src="../static/link-symbol.png"></a></h4><p>Rounds a number up to the nearest integer.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="clamp">clamp<a class="ml8 link" href="#clamp"><img src="../static/link-symbol.png"></a></h4><p>The first argument is clamped between the second and third.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)<br> - <strong>min</strong> (Number)<br> - <strong>max</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="cos">cos<a class="ml8 link" href="#cos"><img src="../static/link-symbol.png"></a></h4><p>The cosine trigonometric function.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="distance_from_nearest_point">distance_from_nearest_point<a class="ml8 link" href="#distance_from_nearest_point"><img src="../static/link-symbol.png"></a></h4><p>Computes the euclidean distance of the position <code>{x, y}</code> from all positions listed in points and returns the shortest distance. The returned distance can be maximum_distance at most.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>points</strong> (MapPositionList)<br> - <strong>maximum_distance</strong> (Number; constant; default = infinity)</p><p><strong>Return type:</strong> Number</p><p><strong>Examples:</strong><br><code>distance_from_nearest_point{x = x, y = y, points = starting_positions} distance_from_nearest_point{x = x, y = y, points = starting_lake_positions}</code></p><h4 id="distance_from_nearest_point_x">distance_from_nearest_point_x<a class="ml8 link" href="#distance_from_nearest_point_x"><img src="../static/link-symbol.png"></a></h4><p>Computes the euclidean distance of the position <code>{x, y}</code> from all positions listed in points and returns the X coordinate of the closest point subtracted from current position.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>points</strong> (MapPositionList)</p><p><strong>Return type:</strong> Number</p><h4 id="distance_from_nearest_point_y">distance_from_nearest_point_y<a class="ml8 link" href="#distance_from_nearest_point_y"><img src="../static/link-symbol.png"></a></h4><p>Computes the euclidean distance of the position <code>{x, y}</code> from all positions listed in points and returns the Y coordinate of the closest point subtracted from current position.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>points</strong> (MapPositionList)</p><p><strong>Return type:</strong> Number</p><h4 id="floor">floor<a class="ml8 link" href="#floor"><img src="../static/link-symbol.png"></a></h4><p>Rounds a number down to the nearest integer.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="if">if<a class="ml8 link" href="#if"><img src="../static/link-symbol.png"></a></h4><p>Copies a value from one of the branches depending on the condition. Does not support short-circuit; all branches are fully evaluated.</p><p><strong>Parameters:</strong><br> - <strong>condition</strong> (Boolean)<br> - <strong>true_branch</strong> (Number)<br> - <strong>false_branch</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="log2">log2<a class="ml8 link" href="#log2"><img src="../static/link-symbol.png"></a></h4><p>Returns a binary logarithm of the given value.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="multisample">multisample<a class="ml8 link" href="#multisample"><img src="../static/link-symbol.png"></a></h4><p>Evaluates the expression in a separate noise program with a larger grid. Sub-grids are copied to the main program. This means that sub-expression results of the given expression are not reused between the main noise program and the multisampling program. Repeated calls of this function with different offsets will be batched together as long as <code>expression</code> is the same.</p><p><strong>Parameters:</strong><br> - <strong>expression</strong> (Number-returning Expression)<br> - <strong>offset_x</strong> (Number; constant 8-bit signed integer)<br> - <strong>offset_y</strong> (Number; constant 8-bit signed integer)</p><p><strong>Return type:</strong> Number</p><h4 id="multioctave_noise">multioctave_noise<a class="ml8 link" href="#multioctave_noise"><img src="../static/link-symbol.png"></a></h4><p>A Factorio multi-octave noise implementation.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>persistence</strong> (Number; constant): how strong each layer is compared to the next larger one<br> - <strong>seed0</strong> (Number; constant; converted to 32-bit unsigned integer)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>octaves</strong> (Number; constant 32-bit unsigned integer): how many layers of noise at different scales to sum<br> - <strong>input_scale</strong> (Number; constant; default = 1): x and y will be multiplied by this before sampling<br> - <strong>output_scale</strong> (Number; constant; default = 1): output will be multiplied by this before being returned<br> - <strong>offset_x</strong> (Number; constant; default = 0): will be added to x before applying input_scale<br> - <strong>offset_y</strong> (Number; constant; default = 0): will be added to y before applying input_scale</p><p><strong>Return type:</strong> Number</p><p>Using <code>input_scale</code> and <code>output_scale</code> is more efficient than multiplying <code>x</code> and <code>y</code> directly; see the<br><a href="#noise-seed-input-scale-and-output-scale">performance tips</a>.</p><p><strong>Examples:</strong><br><code>multioctave_noise{x = x, y = y, persistence = 0.75, seed0 = map_seed, seed1 = 0, octaves = 3} multioctave_noise{x = x, y = y, persistence = 0.75, seed0 = map_seed, seed1 = 0, octaves = 4, input_scale = 1/3, output_scale = 3}</code></p><h4 id="noise_layer_id">noise_layer_id<a class="ml8 link" href="#noise_layer_id"><img src="../static/link-symbol.png"></a></h4><p>Returns the numeric value of the given string to be used as a noise layer ID.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (String)</p><p><strong>Return type:</strong> Number</p><h4 id="pow">pow<a class="ml8 link" href="#pow"><img src="../static/link-symbol.png"></a></h4><p>Fast (inaccurate) exponentiation from <a href="https://code.google.com/archive/p/fastapprox/">fastapprox</a> library. Same as <code>x ^ y</code> operator.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)<br> - <strong>exponent</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="pow_precise">pow_precise<a class="ml8 link" href="#pow_precise"><img src="../static/link-symbol.png"></a></h4><p>Precise (but very slow) exponentiation - it is almost always overkill for map generation.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)<br> - <strong>exponent</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="quick_multioctave_noise">quick_multioctave_noise<a class="ml8 link" href="#quick_multioctave_noise"><img src="../static/link-symbol.png"></a></h4><p>An alternative Factorio multi-octave noise implementation. If possible, prefer using regular multioctave noise.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>seed0</strong> (Number; constant; converted to 32-bit unsigned integer)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>octaves</strong> (Number; constant 32-bit unsigned integer): how many layers of noise at different scales to sum<br> - <strong>input_scale</strong> (Number; constant; default = 1): x and y will be multiplied by this before sampling<br> - <strong>output_scale</strong> (Number; constant; default = 1): output will be multiplied by this before being returned<br> - <strong>offset_x</strong> (Number; constant; default = 0): will be added to x before applying input_scale<br> - <strong>offset_y</strong> (Number; constant; default = 0): will be added to y before applying input_scale<br> - <strong>octave_input_scale_multiplier</strong> (Number; constant; default = 0.5)<br> - <strong>octave_output_scale_multiplier</strong> (Number; constant; default = 2)<br> - <strong>octave_seed0_shift</strong> (Number; constant; default = 1)</p><p><strong>Return type:</strong> Number</p><h4 id="random_penalty">random_penalty<a class="ml8 link" href="#random_penalty"><img src="../static/link-symbol.png"></a></h4><p>Subtracts a random value in the [0, amplitude) range from source if source is larger than 0.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number): a number used to seed the random generator<br> - <strong>y</strong> (Number): a number used to seed the random generator<br> - <strong>source</strong> (Number): a number the penalty is applied to<br> - <strong>seed</strong> (Number; constant; default = 1): a number used to seed the random generator<br> - <strong>amplitude</strong> (Number; constant; default = 1)</p><p><strong>Return type:</strong> Number</p><h4 id="ridge">ridge<a class="ml8 link" href="#ridge"><img src="../static/link-symbol.png"></a></h4><p>Similar to clamp but the input value is folded back across the upper and lower limits until it lies between them.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)<br> - <strong>min</strong> (Number)<br> - <strong>max</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="sin">sin<a class="ml8 link" href="#sin"><img src="../static/link-symbol.png"></a></h4><p>The sine trigonometric function.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="spot_noise">spot_noise<a class="ml8 link" href="#spot_noise"><img src="../static/link-symbol.png"></a></h4><p>Generates random conical spots. The map is divided into square regions. Within each region, candidate points are chosen at random, taking into account skip_span. Then, target density, spot quantity, and radius are calculated for each candidate point by configured expressions. Each spot contributes a quantity to a regional target total (which is the average of sampled target densities times the area of the region) until the total has been reached or a maximum spot count is hit.<br> The output value of the function is the maximum height of any spot at a given point.</p><p>The quantity of the spot is assumed to be the same as its volume. Since the volume of a cone is <code>pi * radius^2 * height / 3</code>, the height ('peak value') of any given spot is calculated as <code>3 * quantity / (pi * radius^2)</code>.</p><p>The infinite series of candidate points (of which <code>candidate_point_count</code> are actually considered) generated by spot noise expressions with the same <code>seed0</code>, <code>seed1</code>, <code>region_size</code> and <code>suggested_minimum_candidate_point_spacing</code> will be identical. This allows multiple spot noise expressions (e.g. for different ore patches) to avoid overlap by using different points from the same list, determined by <code>skip_span</code> and <code>skip_offset</code>.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>density_expression</strong> (Number-returning Expression): an expression which will be evaluated for each candidate spot to calculate density at that point<br> - <strong>spot_quantity_expression</strong> (Number-returning Expression): an expression which will be evaluated for each candidate spot to calculate the spot's quantity<br> - <strong>spot_radius_expression</strong> (Number-returning Expression): an expression which will be evaluated for each candidate spot to calculate the spot's radius (this, together with quantity, will determine the spot's peak value)<br> - <strong>spot_favorability_expression</strong> (Number-returning Expression): an expression which will be evaluated for each candidate spot to calculate the spot's favorability; spots with higher favorability will be considered first when building the final list of spots for a region<br> - <strong>seed0</strong> (Number; constant; converted to 32-bit unsigned integer)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>basement_value</strong> (Number; constant)<br> - <strong>maximum_spot_basement_radius</strong> (Number; constant)<br> - <strong>region_size</strong> (Number; constant; default = 512)<br> - <strong>skip_offset</strong> (Number; constant; default = 0): offset of the first candidate point to use<br> - <strong>skip_span</strong> (Number; constant; default = 1): number of candidate points to skip over after each one used as a spot including the used one<br> - <strong>hard_region_target_quantity</strong> (Boolean; constant; default = true): whether to place a hard limit on the total quantity in each region by reducing the size of any spot (which will be the last spot chosen) that would put it over the limit<br> - <strong>candidate_point_count</strong> (Number; constant; optional): the number of candidate points to generate<br> - <strong>candidate_spot_count</strong> (Number; constant; optional): the number of spots to generate (an alternative to candidate_point_count); <code>candidate_spot_count</code> is equivalent to <code>candidate_point_count / skip_span</code><br> - <strong>suggested_minimum_candidate_point_spacing</strong> (Number; constant; optional): minimum spacing to <em>try</em> to achieve while randomly picking points; spot noise may end up placing spots closer than this in crowded regions</p><p><strong>Return type:</strong> Number</p><h4 id="sqrt">sqrt<a class="ml8 link" href="#sqrt"><img src="../static/link-symbol.png"></a></h4><p>Returns the square root of the given parameter.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)</p><p><strong>Return type:</strong> Number</p><h4 id="terrace">terrace<a class="ml8 link" href="#terrace"><img src="../static/link-symbol.png"></a></h4><p><strong>Parameters:</strong><br> - <strong>value</strong> (Number)<br> - <strong>strength</strong> (Number)<br> - <strong>offset</strong> (Number; constant)<br> - <strong>width</strong> (Number; constant)</p><p><strong>Return type:</strong> Number</p><h4 id="var">var<a class="ml8 link" href="#var"><img src="../static/link-symbol.png"></a></h4><p>Returns the variable specified by the given string. This is useful for variable names with special characters, such as "-" in an expression name.</p><p><strong>Parameters:</strong><br> - <strong>value</strong> (String)</p><p><strong>Return type:</strong> Variable</p><h4 id="variable_persistence_multioctave_noise">variable_persistence_multioctave_noise<a class="ml8 link" href="#variable_persistence_multioctave_noise"><img src="../static/link-symbol.png"></a></h4><p>Same as multioctave_noise implementation except that it supports variable persistence.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>persistence</strong> (Number): how strong each layer is compared to the next larger one<br> - <strong>seed0</strong> (Number; constant; converted to 32-bit unsigned integer)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>octaves</strong> (Number; constant 32-bit unsigned integer): how many layers of noise at different scales to sum<br> - <strong>input_scale</strong> (Number; constant; default = 1): x and y will be multiplied by this before sampling<br> - <strong>output_scale</strong> (Number; constant; default = 1): output will be multiplied by this before being returned<br> - <strong>offset_x</strong> (Number; constant; default = 0): will be added to x before applying input_scale<br> - <strong>offset_y</strong> (Number; constant; default = 0): will be added to y before applying input_scale</p><p><strong>Return type:</strong> Number</p><h4 id="voronoi_spot_noise">voronoi_spot_noise<a class="ml8 link" href="#voronoi_spot_noise"><img src="../static/link-symbol.png"></a></h4><p>The distance from the current location to the closest point (0 at each point and descending to negative values in a cone around each point).</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>seed0</strong> (Number; constant)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>grid_size</strong> (Number; constant 16-bit unsigned integer): Determines the grid that points are placed into.<br> - <strong>distance_type</strong> (Number or String; enum): The function used for distance computation.<br> - <strong>jitter</strong> (Number; constant 0-1; default = 0.5): 0 = all points in the centre of each cell, 1 = all points randomized within the grid cell.</p><p><strong>Available values for <code>distance_type</code>:</strong><br> - <strong>chebyshev</strong> (0): <code>max(abs(x), abs(y))</code><br> - <strong>manhattan</strong> (1): <code>abs(x) + abs(y)</code><br> - <strong>euclidean</strong> (2): <code>(x^2 + y^2)^0.5</code><br> - <strong>minkowski3</strong> (3): <code>(x^3 + y^3)^(1/3)</code></p><p><strong>Return type:</strong> Number</p><h4 id="voronoi_facet_noise">voronoi_facet_noise<a class="ml8 link" href="#voronoi_facet_noise"><img src="../static/link-symbol.png"></a></h4><p>The distance from the 2nd closest point minus the distance to the closest point (0 at a cell boundary, increasing from the edge in facets).</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>seed0</strong> (Number; constant)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>grid_size</strong> (Number; constant 16-bit unsigned integer): Determines the grid that points are placed into.<br> - <strong>distance_type</strong> (Number or String; enum): The function used for distance computation.<br> - <strong>jitter</strong> (Number; constant 0-1; default = 0.5): 0 = all points in the centre of each cell, 1 = all points randomized within the grid cell.</p><p><strong>Available values for <code>distance_type</code>:</strong><br> - <strong>chebyshev</strong> (0): <code>max(abs(x), abs(y))</code><br> - <strong>manhattan</strong> (1): <code>abs(x) + abs(y)</code><br> - <strong>euclidean</strong> (2): <code>(x^2 + y^2)^0.5</code><br> - <strong>minkowski3</strong> (3): <code>(x^3 + y^3)^(1/3)</code></p><p><strong>Return type:</strong> Number</p><h4 id="voronoi_pyramid_noise">voronoi_pyramid_noise<a class="ml8 link" href="#voronoi_pyramid_noise"><img src="../static/link-symbol.png"></a></h4><p>Like facet noise but the gradient is uniform and represents the distance to the closest edge.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>seed0</strong> (Number; constant)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>grid_size</strong> (Number; constant 16-bit unsigned integer): Determines the grid that points are placed into.<br> - <strong>distance_type</strong> (Number or String; enum): The function used for distance computation. <br> - <strong>jitter</strong> (Number; constant 0-1; default = 0.5): 0 = all points in the centre of each cell, 1 = all points randomized within the grid cell.</p><p><strong>Available values for <code>distance_type</code>:</strong><br> - <strong>chebyshev</strong> (0): <code>max(abs(x), abs(y))</code><br> - <strong>manhattan</strong> (1): <code>abs(x) + abs(y)</code><br> - <strong>euclidean</strong> (2): <code>(x^2 + y^2)^0.5</code></p><p><strong>Return type:</strong> Number</p><h4 id="voronoi_cell_id">voronoi_cell_id<a class="ml8 link" href="#voronoi_cell_id"><img src="../static/link-symbol.png"></a></h4><p>A random value from 0 to 1 assigned per cell that is the same for all points within the cell.</p><p><strong>Parameters:</strong><br> - <strong>x</strong> (Number)<br> - <strong>y</strong> (Number)<br> - <strong>seed0</strong> (Number; constant)<br> - <strong>seed1</strong> (NoiseLayerID; constant)<br> - <strong>grid_size</strong> (Number; constant 16-bit unsigned integer): Determines the grid that points are placed into.<br> - <strong>distance_type</strong> (Number or String; enum): The function used for distance computation.<br> - <strong>jitter</strong> (Number; constant 0-1; default = 0.5): 0 = all points in the centre of each cell, 1 = all points randomized within the grid cell.</p><p><strong>Available values for <code>distance_type</code>:</strong><br> - <strong>chebyshev</strong> (0): <code>max(abs(x), abs(y))</code><br> - <strong>manhattan</strong> (1): <code>abs(x) + abs(y)</code><br> - <strong>euclidean</strong> (2): <code>(x^2 + y^2)^0.5</code><br> - <strong>minkowski3</strong> (3): <code>(x^3 + y^3)^(1/3)</code></p><p><strong>Return type:</strong> Number</p><h2 id="performance-tips">Performance tips<a class="ml8 link" href="#performance-tips"><img src="../static/link-symbol.png"></a></h2><p>Noise expressions are parsed into AST (abstract syntax tree) following the operator precedence rules. Each AST node is treated separately - the compiler does not see them in a larger context. This is important when it comes to optimization. Expression <code>x + y + z</code> is parsed as <code>(x + y) + z</code> and <code>y + z + x</code> is parsed as <code>(y + z) + x</code>. So, <code>x + y + z</code> and <code>y + z + x</code> are two different expressions despite producing the same result. However, the compiler recognizes commutativity in individual expressions, so <code>x + y</code> and <code>y + x</code> are identical.</p><p>When MapGenSettings change, noise expressions are compiled into a sequence of noise operations. At this point, the compiler tries to optimize them. This section will mostly cover such optimizations.</p><h3 id="constant-folding">Constant folding<a class="ml8 link" href="#constant-folding"><img src="../static/link-symbol.png"></a></h3><p>The compiler implements simple constant folding. If an AST node (function/operator) has all arguments constant, the expression result is computed directly. Therefore, try to place expressions which could be constant first to take advantage of this optimization.<br> - <code>x + 1 + 2</code> -&gt; <code>(x + 1) + 2</code> (no folding)<br> - <code>1 + 2 + x</code> -&gt; <code>(1 + 2) + x</code> -&gt; <code>3 + x</code> (1 + 2 was folded into 3)<br> - <code>x ^ 2 ^ 3</code> -&gt; <code>x ^ (2 ^ 3)</code> -&gt; <code>x ^ 8</code> (2 ^ 3 was folded into 8)<br> - <code>2 ^ 3 ^ x</code> -&gt; <code>2 ^ (3 ^ x)</code> (no folding)<br> - <code>2 * map_width * map_height * x</code> -&gt; <code>&lt;constant&gt; * x</code> (folded at compile time because map_width and map_height are known constants)<br> - <code>2 + clamp(map_seed, -50, 50) - x</code> -&gt; <code>&lt;constant&gt; - x</code> (folded at compile time because map_seed is a known constant)</p><p>If one of them is a constant, the compiler will try to fold it using built-in rules based on arithmetic identities. It can also apply other optimizations. These rules make the compiler to treat left-hand side expressions as identical to right-hand side expressions.<br> - <code>x + 0</code> -&gt; <code>x</code> (adding 0 doesn't change the result)<br> - <code>x - 0</code> -&gt; <code>x</code> (subtracting 0 doesn't change the result)<br> - <code>0 - x</code> -&gt; <code>-x</code> (unary minus is more efficient)<br> - <code>x * (-1)</code> -&gt; <code>-x</code> (unary minus is more efficient)<br> - <code>x * 0</code> -&gt; <code>0</code> (multiplying by 0 is always 0)<br> - <code>x * 1</code> -&gt; <code>x</code> (multiplying by 1 doesn't change the result)<br> - <code>x / (-1)</code> -&gt; <code>-x</code> (unary minus is more efficient)<br> - <code>x / 1</code> -&gt; <code>x</code> (dividing by 1 doesn't change the result)<br> - <code>x ^ 0</code> -&gt; <code>1</code> (anything to the 0 power is 1)<br> - <code>x ^ 0.5</code> -&gt; <code>sqrt(x)</code> (sqrt is more efficient)<br> - <code>x ^ 1</code> -&gt; <code>x</code> (exponentiation by 1 doesn't change the result)<br> - <code>x ^ 2</code> -&gt; <code>x * x</code> (multiplication is more efficient in this case)</p><p>In addition, integer powers (such as <code>x^(-2)</code>, <code>x^5</code>) have their own specialized noise operation for extra optimization.</p><h3 id="compile-time-deduplication">Compile-time deduplication<a class="ml8 link" href="#compile-time-deduplication"><img src="../static/link-symbol.png"></a></h3><p>The compiler tries to deduplicate noise expressions which are the same. The expressions need to be identical because the compiler is not smart enough to figure out that <code>x + y + z</code> and <code>y + z + x</code> produce the same result. It is good practice to help the compiler with this process.</p><p>Let's say we have these 4 main expressions. How many noise operations will the compiler create after deduplication? Note that constants have their own noise operation and can be deduplicated.<br> - <code>10 * (x + y)</code><br> - <code>10 * (x - y)</code><br> - <code>10 * (-x + y)</code><br> - <code>20 + 10 * (-x - y)</code></p><p>The answer is 12. Constant <code>10</code> is used 4x, <code>-x</code> is used 2x, and none of the other expressions are deduplicated.<br> - <code>10 * (x + y)</code>: 3 new operations: <code>10</code>, <code>x + y</code>, <code>10 * (x + y)</code><br> - <code>10 * (x - y)</code>: 2 new operations: <code>x - y</code>, <code>10 * (x - y)</code><br> - <code>10 * (-x + y)</code>: 3 new operations: <code>-x</code>, <code>-x + y</code>, <code>10 * (-x + y)</code><br> - <code>20 + 10 * (-x - y)</code>: 4 new operations: <code>-x - y</code>, <code>10 * (-x - y)</code>, <code>20</code>, <code>20 + 10 * (-x - y)</code></p><p>We can rewrite the expressions in such way that they use less noise operations.<br> - <code>10 * x + 10 * y</code>: 4 new operations: <code>10</code>, <code>10 * x</code>, <code>10 * y</code>, <code>10 * x + 10 * y</code><br> - <code>10 * x - 10 * y</code>: 1 new operation: <code>10 * x - 10 * y</code><br> - <code>10 * y - 10 * x</code>: 1 new operation: <code>10 * y - 10 * x</code><br> - <code>20 - (10 * x + 10 * y)</code>: 2 new operations <code>20</code>, <code>20 - (10 * x + 10 * y)</code></p><p>The rewritten expressions only use 8 noise operations. Mind the brackets in the last expression - they allow us to fully reuse the result from the first one.</p><p>Sometimes it's not only about getting less noise operations because some may be more expensive than others. If you enable verbose logging in-game, you will get a report with estimated noise program complexity in the log file after creating a surface or changing MapGenSettings. This is what you should target when doing these optimizations: the smallest possible complexity.</p><div class="codehilite" style="background: #263238"><pre style="line-height: 125%;"><span></span><code><span style="color: #F78C6C">22.290</span><span style="color: #EFF"> </span><span style="color: #89DDFF">Verbose</span><span style="color: #EFF"> </span><span style="color: #89DDFF">CompiledMapGenSettings.</span><span style="color: #FFCB6B">cpp</span><span style="color: #89DDFF">:</span><span style="color: #FF5370">335</span><span style="color: #89DDFF">:</span><span style="color: #EFF"> </span><span style="color: #FF5370">&quot;</span><span style="color: #FFCB6B">MapGenSettings</span><span style="color: #EFF"> </span><span style="color: #89DDFF">compilation</span><span style="color: #EFF"> </span><span style="color: #89DDFF">took</span><span style="color: #EFF"> </span><span style="color: #F78C6C">0.031893</span><span style="color: #EFF"> </span><span style="color: #89DDFF">seconds.</span><span style="color: #FF5370">&quot;</span>
<span style="color: #FF5370">22</span><span style="color: #89DDFF">.</span><span style="color: #FF5370">290</span><span style="color: #EFF"> </span><span style="color: #FFCB6B">Verbose</span><span style="color: #EFF"> </span><span style="color: #89DDFF">CompiledMapGenSettings.</span><span style="color: #FFCB6B">cpp</span><span style="color: #89DDFF">:</span><span style="color: #FF5370">355</span><span style="color: #89DDFF">:</span><span style="color: #EFF">   </span><span style="color: #FF5370">&quot;</span><span style="color: #FFCB6B">Cliff</span><span style="color: #EFF"> </span><span style="color: #89DDFF">noise</span><span style="color: #EFF"> </span><span style="color: #89DDFF">program</span><span style="color: #EFF"> </span><span style="color: #89DDFF">processed</span><span style="color: #EFF"> </span><span style="color: #F78C6C">141</span><span style="color: #EFF"> </span><span style="color: #82AAFF">expressions</span><span style="color: #EFF"> </span><span style="color: #89DDFF">(</span><span style="color: #F78C6C">81</span><span style="color: #EFF"> </span><span style="color: #89DDFF">unique)</span><span style="color: #EFF"> </span><span style="color: #89DDFF; font-style: italic">and</span><span style="color: #EFF"> </span><span style="color: #89DDFF">has</span><span style="color: #EFF"> </span><span style="color: #F78C6C">54</span><span style="color: #EFF"> </span><span style="color: #89DDFF">operations</span><span style="color: #EFF"> </span><span style="color: #89DDFF; font-style: italic">and</span><span style="color: #EFF"> </span><span style="color: #F78C6C">13</span><span style="color: #EFF"> </span><span style="color: #89DDFF">registers;</span><span style="color: #EFF"> </span><span style="color: #89DDFF">estimated</span><span style="color: #EFF"> </span><span style="color: #89DDFF">complexity:</span><span style="color: #EFF"> </span><span style="color: #FF5370">593</span><span style="color: #89DDFF">.</span><span style="color: #FF5370">&quot;</span>
<span style="color: #FF5370">22</span><span style="color: #89DDFF">.</span><span style="color: #FF5370">291</span><span style="color: #EFF"> </span><span style="color: #FFCB6B">Verbose</span><span style="color: #EFF"> </span><span style="color: #89DDFF">CompiledMapGenSettings.</span><span style="color: #FFCB6B">cpp</span><span style="color: #89DDFF">:</span><span style="color: #FF5370">355</span><span style="color: #89DDFF">:</span><span style="color: #EFF">   </span><span style="color: #FF5370">&quot;</span><span style="color: #FFCB6B">Entity</span><span style="color: #EFF"> </span><span style="color: #89DDFF">noise</span><span style="color: #EFF"> </span><span style="color: #89DDFF">program</span><span style="color: #EFF"> </span><span style="color: #89DDFF">processed</span><span style="color: #EFF"> </span><span style="color: #F78C6C">4241</span><span style="color: #EFF"> </span><span style="color: #82AAFF">expressions</span><span style="color: #EFF"> </span><span style="color: #89DDFF">(</span><span style="color: #F78C6C">1813</span><span style="color: #EFF"> </span><span style="color: #89DDFF">unique)</span><span style="color: #EFF"> </span><span style="color: #89DDFF; font-style: italic">and</span><span style="color: #EFF"> </span><span style="color: #89DDFF">has</span><span style="color: #EFF"> </span><span style="color: #F78C6C">1249</span><span style="color: #EFF"> </span><span style="color: #89DDFF">operations</span><span style="color: #EFF"> </span><span style="color: #89DDFF; font-style: italic">and</span><span style="color: #EFF"> </span><span style="color: #F78C6C">141</span><span style="color: #EFF"> </span><span style="color: #89DDFF">registers;</span><span style="color: #EFF"> </span><span style="color: #89DDFF">estimated</span><span style="color: #EFF"> </span><span style="color: #89DDFF">complexity:</span><span style="color: #EFF"> </span><span style="color: #FF5370">23391</span><span style="color: #89DDFF">.</span><span style="color: #FF5370">&quot;</span>
<span style="color: #FF5370">22</span><span style="color: #89DDFF">.</span><span style="color: #FF5370">291</span><span style="color: #EFF"> </span><span style="color: #FFCB6B">Verbose</span><span style="color: #EFF"> </span><span style="color: #89DDFF">CompiledMapGenSettings.</span><span style="color: #FFCB6B">cpp</span><span style="color: #89DDFF">:</span><span style="color: #FF5370">355</span><span style="color: #89DDFF">:</span><span style="color: #EFF">   </span><span style="color: #FF5370">&quot;</span><span style="color: #FFCB6B">Tile</span><span style="color: #EFF"> </span><span style="color: #89DDFF">noise</span><span style="color: #EFF"> </span><span style="color: #89DDFF">program</span><span style="color: #EFF"> </span><span style="color: #89DDFF">processed</span><span style="color: #EFF"> </span><span style="color: #F78C6C">1034</span><span style="color: #EFF"> </span><span style="color: #82AAFF">expressions</span><span style="color: #EFF"> </span><span style="color: #89DDFF">(</span><span style="color: #F78C6C">456</span><span style="color: #EFF"> </span><span style="color: #89DDFF">unique)</span><span style="color: #EFF"> </span><span style="color: #89DDFF; font-style: italic">and</span><span style="color: #EFF"> </span><span style="color: #89DDFF">has</span><span style="color: #EFF"> </span><span style="color: #F78C6C">411</span><span style="color: #EFF"> </span><span style="color: #89DDFF">operations</span><span style="color: #EFF"> </span><span style="color: #89DDFF; font-style: italic">and</span><span style="color: #EFF"> </span><span style="color: #F78C6C">49</span><span style="color: #EFF"> </span><span style="color: #89DDFF">registers;</span><span style="color: #EFF"> </span><span style="color: #89DDFF">estimated</span><span style="color: #EFF"> </span><span style="color: #89DDFF">complexity:</span><span style="color: #EFF"> </span><span style="color: #FF5370">17616</span><span style="color: #89DDFF">.</span><span style="color: #FF5370">&quot;</span>
</code></pre></div><h3 id="noise-seed,-scale-and-offsets">Noise seed, scale and offsets<a class="ml8 link" href="#noise-seed,-scale-and-offsets"><img src="../static/link-symbol.png"></a></h3><p>Noise seed usually comes in pair - <code>seed0</code> (main seed) and <code>seed1</code> (auxiliary seed). Unless you have a good reason not to (e.g. you want a static seed), <code>seed0</code> should always be <code>map_seed</code> to keep things simple and <code>seed1</code> should either be sequential (again, for simplicity) or a string - random values are confusing.</p><div class="codehilite" style="background: #263238"><pre style="line-height: 125%;"><span></span><code><span style="color: #89DDFF">Correct:</span>
<span style="color: #EFF">  </span><span style="color: #FFCB6B">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x, y = y, seed0 = map_seed, seed1 = 0}&quot;</span>
<span style="color: #EFF">  </span><span style="color: #89DDFF">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x, y = y, seed0 = map_seed, seed1 = </span><span style="color: #EFF">\&quot;</span><span style="color: #C3E88D">my-named-noise</span><span style="color: #EFF">\&quot;</span><span style="color: #C3E88D">}&quot;</span>

<span style="color: #89DDFF">Incorrect:</span>
<span style="color: #EFF">  </span><span style="color: #FFCB6B">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x, y = y, seed0 = map_seed, seed1 = 44869}&quot;</span>
<span style="color: #EFF">  </span><span style="color: #89DDFF">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x, y = y, seed0 = map_seed + 20, seed1 = 0}&quot;</span>
</code></pre></div><p>Next, it's more performant to use built-in <code>input_scale</code> and <code>output_scale</code> parameters to achieve symmetrical scaling than multiplying <code>x</code>/<code>y</code> variables or the result. This is especially important for <code>input_scale</code> because the trivial case of <code>x = x</code> and <code>y = y</code> is optimized (in general, around 5x faster). The same is true for <code>offset_x</code> and <code>offset_y</code>.</p><div class="codehilite" style="background: #263238"><pre style="line-height: 125%;"><span></span><code><span style="color: #89DDFF">Correct:</span>
<span style="color: #EFF">  </span><span style="color: #FFCB6B">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x, y = y, input_scale = 2, output_scale = 1, seed0 = map_seed, seed1 = 0}&quot;</span>
<span style="color: #EFF">  </span><span style="color: #89DDFF">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x, y = y, input_scale = 1, output_scale = 2, seed0 = map_seed, seed1 = 0}&quot;</span>
<span style="color: #EFF">  </span><span style="color: #89DDFF">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x, y = y, offset_x = 100, offset_y = -50, seed0 = map_seed, seed1 = 0}&quot;</span>

<span style="color: #89DDFF">Incorrect:</span>
<span style="color: #EFF">  </span><span style="color: #FFCB6B">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x * 2, y = y * 2, input_scale = 1, output_scale = 1, seed0 = map_seed, seed1 = 0}&quot;</span>
<span style="color: #EFF">  </span><span style="color: #89DDFF">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;2 * basis_noise{x = x, y = y, input_scale = 1, output_scale = 1, seed0 = map_seed, seed1 = 0}&quot;</span>
<span style="color: #EFF">  </span><span style="color: #89DDFF">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x + 100, y = y - 50, seed0 = map_seed, seed1 = 0}&quot;</span>
</code></pre></div><p>This expression needs asymmetrical input parameters, so you should follow deduplication rules to achieve best performance.</p><div class="codehilite" style="background: #263238"><pre style="line-height: 125%;"><span></span><code><span style="color: #89DDFF">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x * 2, y = y * 3, input_scale = 1, output_scale = 1, seed0 = map_seed, seed1 = 0}&quot;</span>
<span style="color: #89DDFF">expression</span><span style="color: #EFF"> </span><span style="color: #89DDFF">=</span><span style="color: #EFF"> </span><span style="color: #C3E88D">&quot;basis_noise{x = x, y = y * 1.5, input_scale = 2, output_scale = 1, seed0 = map_seed, seed1 = 0}&quot;</span>
</code></pre></div><p>Lastly, use regular multi-octave noise instead of quick multi-octave noise if possible. Their performance is very similar.</p></div></div><div class="docs-sidebar mr12 flex-column fs0"><div class="panel-inset breadcrumbs mb0 p4"><span class="breadcrumbs-text"><a href="../defines.html" class="category-link" data-view="list-defines">Defines</a></span><a id="hide-sidebar-button" class="button square-sm" style="float: right;">|&lt;</a></div><div class="panel-inset mb0 fs0 p4 flex"><input id="ref-search" type="text" class="w100p" placeholder="Search..." spellcheck="false"></div><div id="docs-sidebar-list" class="panel-inset-lighter mt0 p2 docs-sidebar-list h100"><h2 class="ml8 mt8 mb0 yellow">General Topics</h2><ul class="panel-hole" id="list-general"><li data-name="Data Lifecycle"><a href="data-lifecycle.html">Data Lifecycle</a><li data-name="Storage"><a href="storage.html">Storage</a><li data-name="Migrations"><a href="migrations.html">Migrations</a><li data-name="Libraries"><a href="libraries.html">Libraries</a><li data-name="Prototype Inheritance Tree"><a href="prototype-tree.html">Prototype Inheritance Tree</a><li data-name="Noise Expressions"><a href="noise-expressions.html" class="white strong">Noise Expressions</a><li data-name="Instrument Mode"><a href="instrument.html">Instrument Mode</a><li data-name="Item Weight"><a href="item-weight.html">Item Weight</a></ul><h2 class="ml8 mt8 mb0 yellow">JSON Docs</h2><ul class="panel-hole" id="list-json"><li data-name="Runtime JSON Format"><a href="json-docs-runtime.html">Runtime JSON Format</a><li data-name="Prototype JSON Format"><a href="json-docs-prototype.html">Prototype JSON Format</a></ul><p><h2 class="ml8 mt8 mb0 yellow"><a class="collapse-link not-selectable" data-view="list-defines" data-collapsed="false"><img src="../static/collapse-symbol.png" class="collapse-icon" style="pointer-events: none;"><img src="../static/expand-symbol.png" class="expand-icon" style="pointer-events: none; display: none;"></a><a href="../defines.html"> Defines</a></h2><ul class="panel-hole" id="list-defines"><li data-name="alert_type"><a href="../defines.html#defines.alert_type">alert_type</a><li data-name="behavior_result"><a href="../defines.html#defines.behavior_result">behavior_result</a><li data-name="build_check_type"><a href="../defines.html#defines.build_check_type">build_check_type</a><li data-name="build_mode"><a href="../defines.html#defines.build_mode">build_mode</a><li data-name="cargo_destination"><a href="../defines.html#defines.cargo_destination">cargo_destination</a><li data-name="chain_signal_state"><a href="../defines.html#defines.chain_signal_state">chain_signal_state</a><li data-name="chunk_generated_status"><a href="../defines.html#defines.chunk_generated_status">chunk_generated_status</a><li data-name="command"><a href="../defines.html#defines.command">command</a><li data-name="compound_command"><a href="../defines.html#defines.compound_command">compound_command</a><li data-name="control_behavior"><a href="../defines.html#defines.control_behavior">control_behavior</a><li data-name="controllers"><a href="../defines.html#defines.controllers">controllers</a><li data-name="deconstruction_item"><a href="../defines.html#defines.deconstruction_item">deconstruction_item</a><li data-name="default_icon_size"><a href="../defines.html#defines.default_icon_size">default_icon_size</a><li data-name="difficulty"><a href="../defines.html#defines.difficulty">difficulty</a><li data-name="direction"><a href="../defines.html#defines.direction">direction</a><li data-name="disconnect_reason"><a href="../defines.html#defines.disconnect_reason">disconnect_reason</a><li data-name="distraction"><a href="../defines.html#defines.distraction">distraction</a><li data-name="entity_status"><a href="../defines.html#defines.entity_status">entity_status</a><li data-name="entity_status_diode"><a href="../defines.html#defines.entity_status_diode">entity_status_diode</a><li data-name="events"><a href="../defines.html#defines.events">events</a><li data-name="flow_precision_index"><a href="../defines.html#defines.flow_precision_index">flow_precision_index</a><li data-name="game_controller_interaction"><a href="../defines.html#defines.game_controller_interaction">game_controller_interaction</a><li data-name="group_state"><a href="../defines.html#defines.group_state">group_state</a><li data-name="gui_type"><a href="../defines.html#defines.gui_type">gui_type</a><li data-name="input_action"><a href="../defines.html#defines.input_action">input_action</a><li data-name="input_method"><a href="../defines.html#defines.input_method">input_method</a><li data-name="inventory"><a href="../defines.html#defines.inventory">inventory</a><li data-name="logistic_member_index"><a href="../defines.html#defines.logistic_member_index">logistic_member_index</a><li data-name="logistic_mode"><a href="../defines.html#defines.logistic_mode">logistic_mode</a><li data-name="logistic_section_type"><a href="../defines.html#defines.logistic_section_type">logistic_section_type</a><li data-name="mouse_button_type"><a href="../defines.html#defines.mouse_button_type">mouse_button_type</a><li data-name="moving_state"><a href="../defines.html#defines.moving_state">moving_state</a><li data-name="print_skip"><a href="../defines.html#defines.print_skip">print_skip</a><li data-name="print_sound"><a href="../defines.html#defines.print_sound">print_sound</a><li data-name="prototypes"><a href="../defines.html#defines.prototypes">prototypes</a><li data-name="rail_connection_direction"><a href="../defines.html#defines.rail_connection_direction">rail_connection_direction</a><li data-name="rail_direction"><a href="../defines.html#defines.rail_direction">rail_direction</a><li data-name="rail_layer"><a href="../defines.html#defines.rail_layer">rail_layer</a><li data-name="relative_gui_position"><a href="../defines.html#defines.relative_gui_position">relative_gui_position</a><li data-name="relative_gui_type"><a href="../defines.html#defines.relative_gui_type">relative_gui_type</a><li data-name="render_mode"><a href="../defines.html#defines.render_mode">render_mode</a><li data-name="rich_text_setting"><a href="../defines.html#defines.rich_text_setting">rich_text_setting</a><li data-name="riding"><a href="../defines.html#defines.riding">riding</a><li data-name="robot_order_type"><a href="../defines.html#defines.robot_order_type">robot_order_type</a><li data-name="rocket_silo_status"><a href="../defines.html#defines.rocket_silo_status">rocket_silo_status</a><li data-name="selection_mode"><a href="../defines.html#defines.selection_mode">selection_mode</a><li data-name="shooting"><a href="../defines.html#defines.shooting">shooting</a><li data-name="signal_state"><a href="../defines.html#defines.signal_state">signal_state</a><li data-name="space_platform_state"><a href="../defines.html#defines.space_platform_state">space_platform_state</a><li data-name="target_type"><a href="../defines.html#defines.target_type">target_type</a><li data-name="train_state"><a href="../defines.html#defines.train_state">train_state</a><li data-name="transport_line"><a href="../defines.html#defines.transport_line">transport_line</a><li data-name="wire_connector_id"><a href="../defines.html#defines.wire_connector_id">wire_connector_id</a><li data-name="wire_origin"><a href="../defines.html#defines.wire_origin">wire_origin</a><li data-name="wire_type"><a href="../defines.html#defines.wire_type">wire_type</a></ul></div></div><div class="docs-sidebar-thin mr8 flex-column" style="margin-top: 20px;"><a id="show-sidebar-button" class="button square-sm ml0">&gt;|</a></div></div></div></div></div><div class="footer"><div class="panel"><div class="panel-inset m0 text-center"> Copyright © Wube Software <span class="separator">|</span><a href="../license.html">License</a><span class="separator">|</span><a href="../static/archive.zip">Download</a><span class="separator">|</span><a href="https://forums.factorio.com/viewforum.php?f=233" target="_blank">Feedback</a></div></div></div></body></html>